{"/":{"title":"Introduction","data":{"":"","what-is-roq-about#What is ROQ about?":"ROQ offers ready-to-use UI components and APIs for all essential features you need to build your SaaS application:\nauthentication, authorization, user management, a real time chat system, notifications, file management, and many more.","how-does-it-work#How does it work?":"To use ROQ's features, you ...","getting-started#Getting started":""}},"/another":{"title":"Another Page","data":{"":"let a = 1;\n\nconsole.log(a);","component#Component":"","external-component#External Component":""}},"/feature-guides/access-management":{"title":"Access Management","data":{"":"","introduction#Introduction":"Access management in SaaS applications refers to controlling who can access the application and what actions they can\nperform. This is typically achieved through roles and permissions, which grant different access levels to other users.With ROQ's access management, you can:\ndefine roles and assign them to your users\nsetup permissions and enforce them on your application.","what-are-roles-and-permissions#What are roles and permissions?":"A role is represented by its name. For example, you may define a role called \"admin\" and another role called \"\nmember\". You can also be more specific and use whatever term makes sense in your business, like \"chef\", \"driver\", or\njust \"customer\".Conceptually a role is a set of permissions. Roles are assigned directly to users. In some scenarios, users have\nmultiple roles.You can easily read them in sentences like this:\nA user is an admin\nA user is a chef\nA user is a driver\n\nPermissions define access to a specific type of object. For instance, you specify that a user has “read” access to\nthe sales orders of a restaurant management software.","how-it-works#How it works":"Roles and permissions are defined in the console. Generally, permissions grant access to objects, e.g., \"a user is\nallowed to make an order\". You can specify the access level (read, create, update and delete) and set the scope. The\nscope determines if a user has access to either \"all\" records, only the own records, or to records related to users of a\nuser group. These permissions are automatically enforced on all UI Components and APIs of ROQ.\nYou can also define permissions that are applied to your project!\nSome steps of preparation are needed; please refer to the instructions here: TODO Access Management - Project\nIntegration. First, you must declare your custom domain objects with relations in the console and define your\npermissions based on these objects.Technically the access management works based on a query plan which ROQ computes based on the current user's\nroles&permissions and your objects&relations. The SDK is caching this information locally and only refreshes it\nperiodically. This way, your application is independent of the availability of the ROQ Platform. Furthermore, there is\nno need to send all your data. ROQ only needs to know the schema of your database; the actual queries will be performed\non your side.You can use two functions of the SDK in your project: hasAccess and buildQueryPlan","check-if-a-user-has-access-to-an-object#Check if a user has access to an object.":"The hasAccess method returns true if a user has access to something; otherwise false. You can use it for any object,\nwhether it's an entity from your database, a URL, or a user interface component. See hasAccess SDK for more details.","filter-down-data-of-a-query#Filter down data of a query":"When you retrieve data from your database, you'll often need to filter it by the user's role. For example, let’s say you\nhave a REST endpoint called /sales-orders which returns a list of orders. Depending on the user's role, the result will\nbe different: an \"admin\" will see all the orders, while a \"customer\" will see only their orders. This can result in\ncomplicated WHERE conditions, especially if you have more than these two simple roles.For this scenario, ROQ provides a query builder that automatically creates the required conditions. Using our ORM\nadapter, this can be easily integrated into your project. The generated queries can become quite complex if you have a\ndeep schema. You can read more details about this method here: buildQueryPlan SDK","managing-roles#Managing roles":"A role has a name and a reference. The name should describe the role in an understandable way, like \"admin\", \"chef\" or \"\ndriver\". We recommend using the terminology of your business to avoid confusion.Roles can be managed in ROQ's console.","defining-permissions#Defining permissions":"Permissions are defined for each role individually. How you configure permissions varies depending on whether they are\napplied on your project side or at ROQ, but you'll still use the same roles for both systems.","projects-permissions#Project's permissions":"To define permission for your own application, you need to select an object type (e.g., salesOrder). If you don't find\nthe required object in the dropdown, then it wasn't declared in the preparation. In this case, please refer to the\nintegration guide: Access Management - Project IntegrationFor each object, you can set the access level:\nLevel\tDescription\tRead\tThe user is allowed to retrieve objects\tCreate\tEnables the user to create new objects of the selected type\tUpdate\tEnables the user to update objects of the selected type\tDelete\tEnables the user to delete objects of the selected type\nIn addition you can define the scope:\nScope\tDescription\tAll\tThe user is allowed to access all records\tRestricted\tA given path restricts the access\nThe path defines the correct way from one database table to another. For example, the path always starts at the\ntable representing the user (often, this table is called user ). From here, you can select other tables that are\nrelated until you reach the table that holds objects of the selected type. For instance, a path to a sales order\nobject could look like this: user → salesOrder. A path from a user to an order item could look like\nthis: user -> salesOrder -> salesOrderItemYour custom database schema only defines these paths. Instead, ROQ uses them to build the query plan, which is then used\nto add WHERE conditions to your database queries.","roq-platform-permissions#ROQ Platform permissions":"Permissions that are applied on ROQ's side are defined similarly. The paths are already pre-defined, so you don't need\nto set them up, but the scope needs to be defined differently.Scopes:\nScope\tDescription\tAll\tThe user is allowed to access all records\tOwn\tThe access is restricted to records that are directly related to a user\tTenant\tTODO"}},"/feature-guides/files":{"title":"Files","data":{"":"","introduction#Introduction":"ROQ provides a complete solution for file management including these features:\nFile upload using the UI component\nBulk file upload\nPrivate files\nPublic files\nFile associations","ui-components#UI Components":"ROQ’s file management provides there UI components which can be integrated into your application:\nThe <FileDropZone /> component represents an area on your application where users can drag and drop files to be\nuploaded.","basic-concepts#Basic concepts":"Concept\tDescription\tFile visibility\tA file can be either public or private. Public means that there is a permanent URL which can be used by anyone, while private files can only be accessed by user who are allowed to do so.\tFile categories\tOften it makes sense to group files into project-specific categories, like “USER_FILES” or “CONTRACT_FILES”\tContent types\tThe list of all available types is available here: :question:\tFile status\tThe status of a file which can be one of: UPLOAD_PENDING, READY, CANCELLED or ERROR\tFile association\tWhen a file is stored on ROQ Platform, then it always belongs to another entity. For instance PDF files can be uploaded and related to a contract:"}},"/feature-guides/chat":{"title":"Chat","data":{"":"ROQ’s chat system is a fully fledged messaging interface that enables your app’s users to chat in realtime, or send\nmessages, similar to popular messenger applications.The chat system uses a secure websocket socket connection to send and receive messages in realtime. It can be integrated\nto your application within a few minutes, and then customized to your requirements. It is highly flexible and using a\ncombination of the customizable UI widgets for chat, and the API, you could achieve a wide range of flexibility - from a\nprivate messenger like experience, to even a slack-like experience."}},"/feature-guides/user-groups":{"title":"User Groups","data":{"":"","introduction#Introduction":"We usually interpret a user group as exactly what the name says: “a group of users”. The most common use case is to\nuse\nuser groups to represent Multi-tenancy but there are also lots of other use cases. You\nmay want to group users by their home country or any other characteristic.User groups are often related to your custom domain objects like:\nall users that belong to a restaurant\nall users that belong to a team\nall users that belong to a company\n\nUser groups are used for multiple purposes:\nto notify a group of users\nto define access rights, eg:\nusers of the same restaurant can chat with each other\nthis file can be edited by all users of the same team\nusers of the company can invite each other","manage-user-groups#Manage user groups":"User groups can be managed via console or Create user group API. A user group has a name (e.g. “The Mavericks” or “The\nGourmet Kitchen”). In addition, you can define a project-specific reference that enables you to fetch user groups using\nyour own identifier. User groups are having a type. For instance “The Mavericks” could be of type “Team”, while “Foo\nGlobal” could be of type “Restaurant”.","add-and-remove-users#Add and remove users":"You can add and remove users from a user group in the console or use the Add users to a user group API. Group\nmemberships are also shown for each user in the console."}},"/ui-components/chat-message-bell":{"title":"Chat Message Bell","data":{"":"The <ChatMessageBell /> component is typically used in the head offer your application. It informs the user about\nunread messages in the chat.See this component on Storybook","integration#Integration":"To show the bell component, you can copy this snippet in your code:\n<ChatProvider>\n<ChatNotificationBell showZero />\n</ChatProvider>"}},"/ui-components/file-active-uploads":{"title":"File Active Uploads","data":{"":"","overview#Overview":"The <FileActiveUploads /> component shows a progress bar of all active files uploads. Users can abort and restart\nuploads. This component is typically shown on the bottom right corner of your application but you can place it wherever\nyou like.See this component on Storybook","integration#Integration":"To add the  <FileActiveUploads /> component to your application, you can use the following code:\n<FileActiveUploads\nfiles={[]}\nonCancel={function noRefCheck() {\n}}\nonRestart={function noRefCheck() {\n}}\n/>\n\nProp\tType\tDescription\tDefault\tfiles\tarray\tList of files that are currently uploaded. Each file is represented as an object, see below.\t[]\tfiles.abortController\tAbortController\tInstance of Abort controller object that allows you to abort one or more DOM requests as and when desired.\tundefined\tname\tString\tName of the file\t\tpercentage\tNumber\tFile percentage which was uploaded\t\tsize\tNumber\tSize of file in bytes\t\tstatus\tActiveUploadStatusEnum\tStatus of the file\tUPLOADING\ttemporaryId\tString\tUnique Identifier for the files list\t\tuploadUrl\tString\tUpload URL, to upload file\t\tonCancel\tfunction\tCallback function which is triggered when  User Clicks on Cancel (X) Icon, contains logic on how to cancel file upload\t\tonRestart\tfunction\tCallback function which is triggered when User Clicks on restart Icon, contains logic on how to restart file upload"}}}